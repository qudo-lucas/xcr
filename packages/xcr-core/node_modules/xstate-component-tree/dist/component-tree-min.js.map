{"version":3,"file":"component-tree-min.js","sources":["../src/component-tree.js"],"sourcesContent":["const loadComponent = async ({ item, load, context, event }) => {\n    const result = await load(context, event);\n\n    if(Array.isArray(result)) {\n        const [ component, props ] = await Promise.all(result);\n\n        item.component = component;\n        item.props = props;\n    } else {\n        item.component = result;\n    }\n};\n\nconst loadChild = async ({ child, root }) => {\n    const { _tree } = child;\n    \n    const children = await _tree;\n\n    // Will attach to the state itself if it has a component,\n    // otherwise will attach to the parent\n    root.children.push(...children);\n};\n\nclass ComponentTree {\n    constructor(interpreter, callback, { cache = true } = false) {\n        // Storing off args + options\n        this._interpreter = interpreter;\n        this._callback = callback;\n        this._caching = cache;\n\n        // identifier!\n        this.id = interpreter.id;\n\n        // Count # of times tree has been walked, used by cache & for walk cancellation\n        this._counter = 0;\n\n        // Caching for results of previous walks\n        this._cache = new Map();\n\n        // path -> meta lookup\n        this._paths = new Map();\n\n        // path -> invoked id\n        this._invocables = new Map();\n\n        // invoked id -> child machine\n        this._children = new Map();\n\n        // Expose walk result as a property\n        this._tree = false;\n\n        // Last event this saw, used to re-create the tree when a child transitions\n        this._data = false;\n\n        // Get goin\n        this._prep();\n        this._watch();\n    }\n\n    teardown() {\n        this._paths.clear();\n        this._invocables.clear();\n        this._children.clear();\n        this._cache.clear();\n        \n        this._tree = null;\n        this._data = null;\n        this.options = null;\n\n        this._unsubscribe();\n    }\n\n    // Walk the machine and build up maps of paths to meta info as\n    // well as prepping any load functions for usage later\n    _prep() {\n        const { _paths, _invocables, _interpreter, _caching } = this;\n        const { idMap : ids } = _interpreter.machine;\n\n        // xstate maps ids to state nodes, but the value object only\n        // has paths, so need to create our own path-only map here\n        for(const id in ids) {\n            const { path, meta = false, invoke } = ids[id];\n\n            const key = path.join(\".\");\n\n            if(meta) {\n                _paths.set(key, {\n                    __proto__ : null,\n\n                    cache : _caching,\n\n                    ...meta,\n                });\n            }\n\n            // .invoke is always an array\n            invoke.forEach(({ id : invokeid }) => _invocables.set(key, invokeid));\n        }\n    }\n\n    // Subscribe to an interpreter\n    _watch() {\n        const { _interpreter } = this;\n    \n        // Subscribing will start a run of the machine, so no need to manually\n        // kick one off\n        const { unsubscribe } = _interpreter.subscribe((data) => this._state(data));\n\n        this._unsubscribe = unsubscribe;\n    }\n\n    // Walk a machine via BFS, collecting meta information to build a tree\n    // eslint-disable-next-line max-statements, complexity\n    async _walk() {\n        const {\n           _paths,\n           _invocables,\n           _children,\n           _cache,\n           _counter,\n           _data : { value, context, event },\n        } = this;\n        \n        const loads = [];\n        const root = {\n            __proto__ : null,\n            \n            id       : this.id,\n            children : [],\n        };\n\n        // Set up queue for a breadth-first traversal of all active states\n        let queue;\n\n        if(typeof value === \"string\") {\n            queue = [[ root, value, false ]];\n        } else {\n            queue = Object.keys(value).map((child) =>\n                [ root, child, value[child] ]\n            );\n        }\n\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while(queue.length && _counter === this._counter) {\n            const [ parent, path, values ] = queue.shift();\n\n            // Using let since it can be reassigned if we add a new child\n            let pointer = parent;\n\n            if(_paths.has(path)) {\n                const details = _paths.get(path);\n                let cached = false;\n\n                if(_cache.has(path)) {\n                    cached = _cache.get(path);\n                    \n                    // Only cache items from the previous run are valid\n                    if(cached.counter === this._counter - 1) {\n                        cached.counter = this._counter;\n                    } else {\n                        cached = false;\n                        \n                        _cache.delete(path);\n                    }\n                }\n\n                const { component = false, props = false, load } = details;\n\n                const item = {\n                    __proto__ : null,\n\n                    component : cached ? cached.item.component : component,\n                    props     : cached ? cached.item.props : props,\n                    children  : [],\n                };\n\n                // Run load function and assign the response to the component prop\n                if(load && !cached.loaded) {\n                    const loading = loadComponent({\n                        item,\n                        load,\n                        context,\n                        event,\n                    });\n\n                    // Mark this state loaded in the cache once its actually done\n                    loading.then(() => {\n                        const saved = _cache.get(path);\n\n                        if(saved) {\n                            saved.loaded = true;\n                        }\n                    });\n\n                    loads.push(loading);\n                }\n\n                // Check if this node is\n                // 1) allowed to be cached\n                // 2) not already cached\n                // and then save the result\n                if(details.cache && !cached) {\n                    _cache.set(path, {\n                        __proto__ : null,\n                        \n                        item,\n                        counter : this._counter,\n                        loaded  : false,\n                    });\n                }\n\n                parent.children.push(item);\n                pointer = item;\n            }\n\n            if(_invocables.has(path)) {\n                const id = _invocables.get(path);\n\n                if(_children.has(id)) {\n                    loads.push(loadChild({\n                        child : _children.get(id),\n                        root  : pointer,\n                    }));\n                }\n            }\n\n            if(!values) {\n                continue;\n            }\n\n            if(typeof values === \"string\") {\n                queue.push([ pointer, `${path}.${values}`, false ]);\n\n                continue;\n            }\n\n            queue.push(...Object.keys(values).map((child) =>\n                [ pointer, `${path}.${child}`, values[child] ]\n            ));\n        }\n\n        // await all the load functions\n        await Promise.all(loads);\n\n        return root.children;\n    }\n\n    // Kicks off tree walks & handles overlapping walk behaviors\n    async _run() {\n        const { _children, _callback } = this;\n\n        // Cancel any previous walks, we're the captain now\n        const run = ++this._counter;\n        \n        this._tree = this._walk();\n\n        const [ tree ] = await Promise.all([\n            this._tree,\n            [ ..._children.values() ].map(({ _tree }) => _tree),\n        ]);\n\n        // New run started since this finished, abort\n        if(run !== this._counter) {\n            return;\n        }\n        \n        _callback(tree, { data : this._data });\n    }\n    \n    // Callback for statechart transitions to sync up child machine states\n    _state(data) {\n        const { changed, children } = data;\n\n        // Need to specifically check for false because this value is undefined\n        // when a machine first boots up\n        if(changed === false) {\n            return false;\n        }\n\n        // Save off the event, but only the fields we need\n        this._data = {\n            __proto__ : null,\n\n            value   : data.value,\n            event   : data.event,\n            context : data.context,\n        };\n\n        const { _children } = this;\n        \n        // Clear out any old children that are no longer being tracked\n        _children.forEach((child, key) => {\n            if(key in children) {\n                return;\n            }\n\n            child.teardown();\n            child = null;\n\n            _children.delete(key);\n        });\n\n        // Add any new children to be tracked\n        Object.keys(children).forEach((id) => {\n            if(_children.has(id)) {\n                return;\n            }\n\n            const service = children[id];\n\n            // Not a statechart, abort!\n            if(!service.initialized || !service.state) {\n                return;\n            }\n\n            // Create the child ComponentTree instance, trigger re-walks of the parent after it chnages\n            _children.set(id, new ComponentTree(service, () =>\n                this._run()\n            ));\n        });\n    \n        return this._run();\n    }\n}\n\nexport default ComponentTree;\n"],"names":["loadComponent","async","item","load","context","event","result","Array","isArray","component","props","Promise","all","loadChild","child","root","_tree","children","push","ComponentTree","[object Object]","interpreter","callback","cache","this","_interpreter","_callback","_caching","id","_counter","_cache","Map","_paths","_invocables","_children","_data","_prep","_watch","clear","options","_unsubscribe","idMap","ids","machine","path","meta","invoke","key","join","set","__proto__","forEach","invokeid","unsubscribe","subscribe","data","_state","value","loads","queue","Object","keys","map","length","parent","values","shift","pointer","has","details","get","cached","counter","delete","loaded","loading","then","saved","run","_walk","tree","changed","teardown","service","initialized","state","_run"],"mappings":"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"}