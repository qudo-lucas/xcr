{"version":3,"file":"component-tree.js","sources":["../src/component-tree.js"],"sourcesContent":["const loadComponent = async ({ item, load, context, event }) => {\n    const result = await load(context, event);\n\n    if(Array.isArray(result)) {\n        const [ component, props ] = await Promise.all(result);\n\n        item.component = component;\n        item.props = props;\n    } else {\n        item.component = result;\n    }\n};\n\nconst loadChild = async ({ child, root }) => {\n    const { _tree } = child;\n    \n    const children = await _tree;\n\n    // Will attach to the state itself if it has a component,\n    // otherwise will attach to the parent\n    root.children.push(...children);\n};\n\nclass ComponentTree {\n    constructor(interpreter, callback, { cache = true } = false) {\n        // Storing off args + options\n        this._interpreter = interpreter;\n        this._callback = callback;\n        this._caching = cache;\n\n        // identifier!\n        this.id = interpreter.id;\n\n        // Count # of times tree has been walked, used by cache & for walk cancellation\n        this._counter = 0;\n\n        // Caching for results of previous walks\n        this._cache = new Map();\n\n        // path -> meta lookup\n        this._paths = new Map();\n\n        // path -> invoked id\n        this._invocables = new Map();\n\n        // invoked id -> child machine\n        this._children = new Map();\n\n        // Expose walk result as a property\n        this._tree = false;\n\n        // Last event this saw, used to re-create the tree when a child transitions\n        this._data = false;\n\n        // Get goin\n        this._prep();\n        this._watch();\n    }\n\n    teardown() {\n        this._paths.clear();\n        this._invocables.clear();\n        this._children.clear();\n        this._cache.clear();\n        \n        this._tree = null;\n        this._data = null;\n        this.options = null;\n\n        this._unsubscribe();\n    }\n\n    // Walk the machine and build up maps of paths to meta info as\n    // well as prepping any load functions for usage later\n    _prep() {\n        const { _paths, _invocables, _interpreter, _caching } = this;\n        const { idMap : ids } = _interpreter.machine;\n\n        // xstate maps ids to state nodes, but the value object only\n        // has paths, so need to create our own path-only map here\n        for(const id in ids) {\n            const { path, meta = false, invoke } = ids[id];\n\n            const key = path.join(\".\");\n\n            if(meta) {\n                _paths.set(key, {\n                    __proto__ : null,\n\n                    cache : _caching,\n\n                    ...meta,\n                });\n            }\n\n            // .invoke is always an array\n            invoke.forEach(({ id : invokeid }) => _invocables.set(key, invokeid));\n        }\n    }\n\n    // Subscribe to an interpreter\n    _watch() {\n        const { _interpreter } = this;\n    \n        // Subscribing will start a run of the machine, so no need to manually\n        // kick one off\n        const { unsubscribe } = _interpreter.subscribe((data) => this._state(data));\n\n        this._unsubscribe = unsubscribe;\n    }\n\n    // Walk a machine via BFS, collecting meta information to build a tree\n    // eslint-disable-next-line max-statements, complexity\n    async _walk() {\n        const {\n           _paths,\n           _invocables,\n           _children,\n           _cache,\n           _counter,\n           _data : { value, context, event },\n        } = this;\n        \n        const loads = [];\n        const root = {\n            __proto__ : null,\n            \n            id       : this.id,\n            children : [],\n        };\n\n        // Set up queue for a breadth-first traversal of all active states\n        let queue;\n\n        if(typeof value === \"string\") {\n            queue = [[ root, value, false ]];\n        } else {\n            queue = Object.keys(value).map((child) =>\n                [ root, child, value[child] ]\n            );\n        }\n\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while(queue.length && _counter === this._counter) {\n            const [ parent, path, values ] = queue.shift();\n\n            // Using let since it can be reassigned if we add a new child\n            let pointer = parent;\n\n            if(_paths.has(path)) {\n                const details = _paths.get(path);\n                let cached = false;\n\n                if(_cache.has(path)) {\n                    cached = _cache.get(path);\n                    \n                    // Only cache items from the previous run are valid\n                    if(cached.counter === this._counter - 1) {\n                        cached.counter = this._counter;\n                    } else {\n                        cached = false;\n                        \n                        _cache.delete(path);\n                    }\n                }\n\n                const { component = false, props = false, load } = details;\n\n                const item = {\n                    __proto__ : null,\n\n                    component : cached ? cached.item.component : component,\n                    props     : cached ? cached.item.props : props,\n                    children  : [],\n                };\n\n                // Run load function and assign the response to the component prop\n                if(load && !cached.loaded) {\n                    const loading = loadComponent({\n                        item,\n                        load,\n                        context,\n                        event,\n                    });\n\n                    // Mark this state loaded in the cache once its actually done\n                    loading.then(() => {\n                        const saved = _cache.get(path);\n\n                        if(saved) {\n                            saved.loaded = true;\n                        }\n                    });\n\n                    loads.push(loading);\n                }\n\n                // Check if this node is\n                // 1) allowed to be cached\n                // 2) not already cached\n                // and then save the result\n                if(details.cache && !cached) {\n                    _cache.set(path, {\n                        __proto__ : null,\n                        \n                        item,\n                        counter : this._counter,\n                        loaded  : false,\n                    });\n                }\n\n                parent.children.push(item);\n                pointer = item;\n            }\n\n            if(_invocables.has(path)) {\n                const id = _invocables.get(path);\n\n                if(_children.has(id)) {\n                    loads.push(loadChild({\n                        child : _children.get(id),\n                        root  : pointer,\n                    }));\n                }\n            }\n\n            if(!values) {\n                continue;\n            }\n\n            if(typeof values === \"string\") {\n                queue.push([ pointer, `${path}.${values}`, false ]);\n\n                continue;\n            }\n\n            queue.push(...Object.keys(values).map((child) =>\n                [ pointer, `${path}.${child}`, values[child] ]\n            ));\n        }\n\n        // await all the load functions\n        await Promise.all(loads);\n\n        return root.children;\n    }\n\n    // Kicks off tree walks & handles overlapping walk behaviors\n    async _run() {\n        const { _children, _callback } = this;\n\n        // Cancel any previous walks, we're the captain now\n        const run = ++this._counter;\n        \n        this._tree = this._walk();\n\n        const [ tree ] = await Promise.all([\n            this._tree,\n            [ ..._children.values() ].map(({ _tree }) => _tree),\n        ]);\n\n        // New run started since this finished, abort\n        if(run !== this._counter) {\n            return;\n        }\n        \n        _callback(tree, { data : this._data });\n    }\n    \n    // Callback for statechart transitions to sync up child machine states\n    _state(data) {\n        const { changed, children } = data;\n\n        // Need to specifically check for false because this value is undefined\n        // when a machine first boots up\n        if(changed === false) {\n            return false;\n        }\n\n        // Save off the event, but only the fields we need\n        this._data = {\n            __proto__ : null,\n\n            value   : data.value,\n            event   : data.event,\n            context : data.context,\n        };\n\n        const { _children } = this;\n        \n        // Clear out any old children that are no longer being tracked\n        _children.forEach((child, key) => {\n            if(key in children) {\n                return;\n            }\n\n            child.teardown();\n            child = null;\n\n            _children.delete(key);\n        });\n\n        // Add any new children to be tracked\n        Object.keys(children).forEach((id) => {\n            if(_children.has(id)) {\n                return;\n            }\n\n            const service = children[id];\n\n            // Not a statechart, abort!\n            if(!service.initialized || !service.state) {\n                return;\n            }\n\n            // Create the child ComponentTree instance, trigger re-walks of the parent after it chnages\n            _children.set(id, new ComponentTree(service, () =>\n                this._run()\n            ));\n        });\n    \n        return this._run();\n    }\n}\n\nexport default ComponentTree;\n"],"names":[],"mappings":"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"}