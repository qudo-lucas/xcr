{"version":3,"file":"component-tree-min.mjs","sources":["../src/component-tree.js"],"sourcesContent":["const loadComponent = async ({ item, load, context, event }) => {\n    const result = await load(context, event);\n\n    if(Array.isArray(result)) {\n        const [ component, props ] = await Promise.all(result);\n\n        item.component = component;\n        item.props = props;\n    } else {\n        item.component = result;\n    }\n};\n\nconst loadChild = async ({ child, root }) => {\n    const { _tree } = child;\n    \n    const children = await _tree;\n\n    // Will attach to the state itself if it has a component,\n    // otherwise will attach to the parent\n    root.children.push(...children);\n};\n\nclass ComponentTree {\n    constructor(interpreter, callback, { cache = true } = false) {\n        // Storing off args + options\n        this._interpreter = interpreter;\n        this._callback = callback;\n        this._caching = cache;\n\n        // identifier!\n        this.id = interpreter.id;\n\n        // Count # of times tree has been walked, used by cache & for walk cancellation\n        this._counter = 0;\n\n        // Caching for results of previous walks\n        this._cache = new Map();\n\n        // path -> meta lookup\n        this._paths = new Map();\n\n        // path -> invoked id\n        this._invocables = new Map();\n\n        // invoked id -> child machine\n        this._children = new Map();\n\n        // Expose walk result as a property\n        this._tree = false;\n\n        // Last event this saw, used to re-create the tree when a child transitions\n        this._data = false;\n\n        // Get goin\n        this._prep();\n        this._watch();\n    }\n\n    teardown() {\n        this._paths.clear();\n        this._invocables.clear();\n        this._children.clear();\n        this._cache.clear();\n        \n        this._tree = null;\n        this._data = null;\n        this.options = null;\n\n        this._unsubscribe();\n    }\n\n    // Walk the machine and build up maps of paths to meta info as\n    // well as prepping any load functions for usage later\n    _prep() {\n        const { _paths, _invocables, _interpreter, _caching } = this;\n        const { idMap : ids } = _interpreter.machine;\n\n        // xstate maps ids to state nodes, but the value object only\n        // has paths, so need to create our own path-only map here\n        for(const id in ids) {\n            const { path, meta = false, invoke } = ids[id];\n\n            const key = path.join(\".\");\n\n            if(meta) {\n                _paths.set(key, {\n                    __proto__ : null,\n\n                    cache : _caching,\n\n                    ...meta,\n                });\n            }\n\n            // .invoke is always an array\n            invoke.forEach(({ id : invokeid }) => _invocables.set(key, invokeid));\n        }\n    }\n\n    // Subscribe to an interpreter\n    _watch() {\n        const { _interpreter } = this;\n    \n        // Subscribing will start a run of the machine, so no need to manually\n        // kick one off\n        const { unsubscribe } = _interpreter.subscribe((data) => this._state(data));\n\n        this._unsubscribe = unsubscribe;\n    }\n\n    // Walk a machine via BFS, collecting meta information to build a tree\n    // eslint-disable-next-line max-statements, complexity\n    async _walk() {\n        const {\n           _paths,\n           _invocables,\n           _children,\n           _cache,\n           _counter,\n           _data : { value, context, event },\n        } = this;\n        \n        const loads = [];\n        const root = {\n            __proto__ : null,\n            \n            id       : this.id,\n            children : [],\n        };\n\n        // Set up queue for a breadth-first traversal of all active states\n        let queue;\n\n        if(typeof value === \"string\") {\n            queue = [[ root, value, false ]];\n        } else {\n            queue = Object.keys(value).map((child) =>\n                [ root, child, value[child] ]\n            );\n        }\n\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while(queue.length && _counter === this._counter) {\n            const [ parent, path, values ] = queue.shift();\n\n            // Using let since it can be reassigned if we add a new child\n            let pointer = parent;\n\n            if(_paths.has(path)) {\n                const details = _paths.get(path);\n                let cached = false;\n\n                if(_cache.has(path)) {\n                    cached = _cache.get(path);\n                    \n                    // Only cache items from the previous run are valid\n                    if(cached.counter === this._counter - 1) {\n                        cached.counter = this._counter;\n                    } else {\n                        cached = false;\n                        \n                        _cache.delete(path);\n                    }\n                }\n\n                const { component = false, props = false, load } = details;\n\n                const item = {\n                    __proto__ : null,\n\n                    component : cached ? cached.item.component : component,\n                    props     : cached ? cached.item.props : props,\n                    children  : [],\n                };\n\n                // Run load function and assign the response to the component prop\n                if(load && !cached.loaded) {\n                    const loading = loadComponent({\n                        item,\n                        load,\n                        context,\n                        event,\n                    });\n\n                    // Mark this state loaded in the cache once its actually done\n                    loading.then(() => {\n                        const saved = _cache.get(path);\n\n                        if(saved) {\n                            saved.loaded = true;\n                        }\n                    });\n\n                    loads.push(loading);\n                }\n\n                // Check if this node is\n                // 1) allowed to be cached\n                // 2) not already cached\n                // and then save the result\n                if(details.cache && !cached) {\n                    _cache.set(path, {\n                        __proto__ : null,\n                        \n                        item,\n                        counter : this._counter,\n                        loaded  : false,\n                    });\n                }\n\n                parent.children.push(item);\n                pointer = item;\n            }\n\n            if(_invocables.has(path)) {\n                const id = _invocables.get(path);\n\n                if(_children.has(id)) {\n                    loads.push(loadChild({\n                        child : _children.get(id),\n                        root  : pointer,\n                    }));\n                }\n            }\n\n            if(!values) {\n                continue;\n            }\n\n            if(typeof values === \"string\") {\n                queue.push([ pointer, `${path}.${values}`, false ]);\n\n                continue;\n            }\n\n            queue.push(...Object.keys(values).map((child) =>\n                [ pointer, `${path}.${child}`, values[child] ]\n            ));\n        }\n\n        // await all the load functions\n        await Promise.all(loads);\n\n        return root.children;\n    }\n\n    // Kicks off tree walks & handles overlapping walk behaviors\n    async _run() {\n        const { _children, _callback } = this;\n\n        // Cancel any previous walks, we're the captain now\n        const run = ++this._counter;\n        \n        this._tree = this._walk();\n\n        const [ tree ] = await Promise.all([\n            this._tree,\n            [ ..._children.values() ].map(({ _tree }) => _tree),\n        ]);\n\n        // New run started since this finished, abort\n        if(run !== this._counter) {\n            return;\n        }\n        \n        _callback(tree, { data : this._data });\n    }\n    \n    // Callback for statechart transitions to sync up child machine states\n    _state(data) {\n        const { changed, children } = data;\n\n        // Need to specifically check for false because this value is undefined\n        // when a machine first boots up\n        if(changed === false) {\n            return false;\n        }\n\n        // Save off the event, but only the fields we need\n        this._data = {\n            __proto__ : null,\n\n            value   : data.value,\n            event   : data.event,\n            context : data.context,\n        };\n\n        const { _children } = this;\n        \n        // Clear out any old children that are no longer being tracked\n        _children.forEach((child, key) => {\n            if(key in children) {\n                return;\n            }\n\n            child.teardown();\n            child = null;\n\n            _children.delete(key);\n        });\n\n        // Add any new children to be tracked\n        Object.keys(children).forEach((id) => {\n            if(_children.has(id)) {\n                return;\n            }\n\n            const service = children[id];\n\n            // Not a statechart, abort!\n            if(!service.initialized || !service.state) {\n                return;\n            }\n\n            // Create the child ComponentTree instance, trigger re-walks of the parent after it chnages\n            _children.set(id, new ComponentTree(service, () =>\n                this._run()\n            ));\n        });\n    \n        return this._run();\n    }\n}\n\nexport default ComponentTree;\n"],"names":["loadComponent","async","item","load","context","event","result","Array","isArray","component","props","Promise","all","loadChild","i","child","root","o","_tree","children","push","ComponentTree","[object Object]","interpreter","callback","h","cache","this","_interpreter","_callback","_caching","id","_counter","_cache","Map","_paths","_invocables","_children","_data","_prep","_watch","clear","options","_unsubscribe","v","M","l","p","O","ids","machine","path","T","meta","A","invoke","key","join","set","__proto__","forEach","invokeid","unsubscribe","subscribe","data","_state","g","m","u","$","value","loads","queue","Object","keys","map","length","parent","values","shift","pointer","has","details","get","cached","counter","delete","t","s","loaded","loading","then","saved","D","_","run","_walk","tree","G","changed","teardown","service","initialized","state","_run"],"mappings":"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"}